[TOC]

# 目录

---

**面试重点总结**

`面试中可能会遇到的题目`



# 一、面试重点总结
	线程，进程，IO
	中间件本质
	关系数据库
	web界面开发，Django源码
	数据分析：工具应用熟练，数学理论熟悉
	函数封装
	面向对象
	难点：装饰器
	数据库原理，网络原理，操作系统原理，数据结构和算法(bat)
	求10万以内质数，判断某个数是否为质数，求斐波那契数列第101项或者前都少项（递归，生成器，循环），打印菱形

# 二、面试中可能会遇到的题目
## 1.动态语言的内存管理：
    什么是垃圾回收GC？面向对象编程在内存管理方面的优势和劣势？
    在程序运行时某一些对象的引用计数（sys.getrefcount(x)）可能为0，这些对象会被打上标记，说明为空，这些对象，所占用的碎片化内存，会被整理成连续的内存空间以便后续使用，这个过程叫做垃圾回收。但是垃圾回收时内存不能使用，所以需要在空闲时间整理内存，也不需要频繁整理，看实际需要。
    引用计数增加的方式：
        对象赋值给其他变量例如：x = [1,2] y = x  列表的引用计数加
        函数调用 foo(x)  调用时增加一次，调用完成，恢复原来的次数
    引用计数减少的方式：
        函数运行结束时，局部变量会被自动消除，引用计数减少
        变量赋值给其他对象 x = 3 x = 4, 3的引用计数少一次
    另外， 字面常量的引用计数不容易判断
## 2.元编程
    可能是会拉开差距的面试题

## 3.计算机5大组成部分及各部分的功能

## 4.python语言的特点



# 三、计算机基础知识

## 1.冯诺伊曼体系
+ 计算机5大部分：输入设备，输出设备，内存，cup（包括运算器，和控制器,  寄存器，缓存器）
+ cup：做所有运算，并通过控制器来控制内存，输入输出设备
+ 内存：作为cup和IO之间的桥梁，数据需要从IO设备加载到内存，才能被
  cup使用
+ 内存的特点：断电易失
+ 寄存器：用来暂时存放内存中的数据，速度和cup一样快
+ 多级缓存：用来存放内存中的数据，级数越高速度越慢，存储空间越大
+ 数据流向：IO设备到内存再到cup
+ 计算机中可以存数据的结构：IO设备，内存，cup中还有寄存器和缓存器
+ 个各结构的运算速度：cup >> 内存 >> IO设备

## 2.解释性语言和汇编语言
+ 解释性语言工作流程：源代码被解释器翻译成Bytecode,然后在虚拟机上运行（如pvm）,转换成机器语言

+ 编译语言工作原理：源代码被编译器，直接编译成机器语言
+ 非结构化：多个入口多个出口
+ 结构化：一个入口一个出口
+ Python是多范式的面向对象，结构化，函数式编程



# 四、python基础知识及练习
## 1.进制

    0xa 十六进制
    0b1 二进制
    0o7 八进制

+ 10 进制到 其他进制 用除法取余数
+ 其他进制转10进制 对应位置累乘
+ 2进制以1结尾在10进制中都是奇数
+ 2进制与16进制相互转换容易
+ 8bits(位) = 1byte（字节）
+ 网络一般是bits，u盘一般是1byte

+ 需要记住的16进制到10进制的几个数：
        0x30 48
        0x31 49
        0x41 65
        0x61 97
        0x7F 127
  
+ 例子：
            
    1.  111 二进制
        F 十六进制      
        15 十进制

    2.  0xFF 十六进制 表示256个无符号位
        1111 1111 二进制
        2的8次幂减1 255

    3.  1000 00000 二进制
        2的7次幂 128 十进制
        0x80 十六进制

    4.  0x7F 十六进制
        0111 1111 二进制
        255-128=127 十进制

    5. int('1a', 16) = 16+10=26

## 2.按位运算
    &  位与
    |  位或
    ~  位非
    ^  位异或
+ 例子：
    1. 12的源码,补码,反码都为 0000 1100在按位取反的过程中计算机自动求了补码，～12的按位取反 为1111 0011，计算机认为这是个负数，所以又去了补码（负数的补码为，首位不变，其他位数取反码，并加1），即为1000 1100+1=1000 1101=-13

    2. -1 我们看到的格式为-0b1和1000 0001, 在计算机中的存在格式为1111 1110 + 1=1111 1111 =0xFF。所以0xFF 不仅表示正的255还表示-1 

    3. 0xFE = 0xFF-1=1111 1111 -1 = 1111 1110 = 0xFE

    4. 0xFE的补码即在计算机中的存在格式 1000 0001+1=1000 0010 =-2

    5.异或
    10^9 = 0000 1010 ^ 0000 1001 = 0000 0011=3
    10^-9 = 0000 1010 ^ (1000 1001自己看到的）1111 0110+1 =1111 1101 取补码 1000 0011=-3

## 3.逻辑运算
    逻辑元算
    and
    or
    not 

+ Or短路是指返回表达式第一个位置的值 4 or 5 or 6=4+5+6 返回6
+ and短路是指 第一个位置为0 0 and 5 and 6 =0*5*6 返回0
+ 与false等价的 4个空容器，空串，None，0
+ 运算符的优先顺序: 单目运算符> 双目算数运算符 >比较运算符 >逻辑运算符
+ 例子：
    1. (1 and 0) or (5 and 6) 返回6
    2. 0 or 'abc' 返回‘abc’

## 4.分支及循环
+ 分支： if前面的条件被跳过，后面隐含前面条件
+ If 和elif加条件和冒号 else后面直接加冒号
+ 只有一个条件可以写成 if 3<2:print('111')

+ range(a)前包后不包，是惰性对象，range?查看帮助 ，一般作为计数器，当作为计数器时a大于
+ for i in range(10, -1, -2)打印10，8，6，4，2，0
+ continue  跳过当前一次continue后面的循环，进入到下一次循环，如果当前循环是最后一次，则跳出循环

+ Break终止当前for循环或者其他循环，continue终止本次循环进入下一次循环
+ 例子：
      
    1.  ``` python
        for i in range(100):
            print(i)
            if  i > 2:
                break
            else:
            print('end')
        ```
    + 当如果循环正常执行，并且遇到了break,就认为循环不正常，不执行else(两个条件)，否则都执行else

## 5.特殊符号
+ \n 换行
+ \r 换行
+ \r\n 回车换行
+ r R 加到字符串前面表示不转义
+ \t 四个空格
+ \  在转义前面再加一个反斜杠表示不转义
+ 在字符串最后加上\ 表示不换行
+ f 表示字符串前缀，例如f'{a}, {6}' = '100, 200'

## 6.python语言的特点
+ python是动态的强类型语言，动态语言的特点是不需要事先声明变量，
  可以在使用的同时被声明，使用方便，但是也存在无法判断变量类型问题，强类型语言的特点是只有相同类型变量之间才可以操作  ，例如：python不能运算‘abc’+1, 但是在python中也存在隐式的类型转换，例如：1+0.5=1.5

  

## 7.数值类型

+ int 为长整型，无大小限制，但是受内存限制
+ bool 可以和整型直接运算
+ int 截取整数部分
+ // floored quotient 向下取整
+ math.floor() 向下 math.ceil()向上 round 4舍6入 5取偶
+ math.pi math.e math.sqrt()=2 ** 0.5 pow(2,3) math.pow(2,3) math.log2(4) math.log10(100)=2
+ min(range(5))=0 min([9,0])=0 min(3, 4, 5)=3 max用法相同
+ a = 2 , b = hex(100) 不能这么用
+ bin(100) = 0110 0100  hex(100) = 64 oct(100)=0o144
+ type(12)返回类型 isinstance('abc', (str, int, float))返回布尔

## 8. 容器

### (1). 列表

+ list 索引0-len(a)-1  -len到-1，构建list=[1,2] list=list(range(5)) list=list()

  ​	list 方法：

  ​	alst.len() 时间复杂度O(1)

  ​	alst.append() O(1)

  ​	alst.index(object, 开始索引，结束索引)  O(n) 两个索引范围前包后不包

  ​	alst.count() O(n)

  ​	alst.insert(索引，object)  在索引前面插入，超出索引插在最前面或最后面 O(n)

  ​	alst.extend([1,2]) O(1)

  ​	alst + blst 生成心列表，开劈新空间   **注意**

  ​	alst*5 对当前列表里面的元素操作，例如：[[2,3]乘5]=[[2,3,2,3,2,3,2,3]]生成新列表，开辟新空间，**注意**

  ​	alst.sort(*, key=None, reverse=False) 可选参数和必须写的关键字参数，没生成新的，原地排序，sort有时必须要用，但是少用。例子：

  ```python 
  alst=[1,2,'a']
  #在排序的过程中会转换成字符串，但不改变原来的结果
  alst.sort(key=str)
  #不可以用????
  alst.sort(key=int)
  
  ```

  alst.remove(object) 找不到会报错，会删除第一个找到的object，因为需要先找到再删除，而且需要挪位置，所以效率很低, O(n)

  alst.pop()

  alst.clear()  引用计数标记为0

  修改列表

  ```python
  a = [1,2,3]*2
  a = [1,2,3,1,2,3]
  a[1] = 31
  a = [1,31,3,1,2,3]
  
  # 相乘后a两个位置的元素具有相同地址
  a = [[1,2,3]]*2
  a = [[1,2,3], [1,2,3]]
  a[1][2] = 31
  a = [[1,2,31], [1,2,31]]
  
  #a两个位置元素具有不同地址
  a = [[1,2,3], [1,2,3]]
  a[1][2] = 31
  a = [[1,2,3], [1,2,31]]
  
  #a与b的值相等即 a==b,但是地址不同 copy之后id(a) != id(b), id(a[1])=id(b[1])
  a = [[1,2,3], [1,2,3]]
  b = a.copy()
  a[1][2] = 31
  a = [[1,2,3], [1,2,31]]
  b = [[1,2,3], [1,2,31]]
  
  #a与b的值相等及 a==b, deepcopy之后id(a) != id(b), id(a[1]) != id(b[1])
  a = [[1,2,3], [1,2,3]]
  b = copy.deepcopy()
  a[1][2] = 31
  a = [[1,2,3], [1,2,31]]
  b = [[1,2,3], [1,2,3]]
  
  
  ```

  ![浅拷贝图示](/Users/jw/Projects/python23/马哥教育笔记/copy.png)

  

  

  in  O(n)不要经常用

  als.reverse() 通过对调实现的，一般不用，只需要倒着打印即可

   

  ​	在jupyter notebook里面五out无返回值

+ 链表Linkedlist

+ 栈stack 后进先出

+ 队列queue 先进先出

+ 比较：列表查找很快，因为有索引，但是需要连续的内存空间，插入和删除很慢，两个方向都可以操作；链表因为没有索引，所以查找元素需要从头查找速度慢，但是插入和删除很快，两个方向都可以操作；栈一般用作处理后进后出的数据，一般不做插入删除和索引和计算长度的操作；队列一般用作处理先进先出的数据，一般不做插入删除和索引和计算长度的操作，栈和队列是基于列表和链表实现，以上4种都是顺序线性结构。

  ###  (2) . 元组

  ​	新建元组，() (1,) (1,2)   tuple()

  ​	元组不可以修改：是指里面的值和地址不能修改

  ​	修改元组

  ```python
  tup =(1, (2,3),[4,5,'a',(4,)])
  tup[0] = 31 #不可以修改
  tup[1][1] = 31 #不可以修改
  tup[2][1] = 31 #可以修改
  tup[2][3] = 31 #可以修改
  tup[2][3][0] = #不可以修改
  
  tup = (1,)*3
  tup = (1, 1, 1)
  
  tup = ((1,),)*3
  tup = ((1), (1), (1))
  #tup不可以修改
  
  tup = ([1])*3
  tup = ([1], [1], [1])
  tup[1][0] = 100
  tup = ([100], [100], [100])
  
  tup.index(value, [start, [stop]])
  tup = (1,2,3,4,5,5,4,3)
  tup.index(3, 5) #从第5个索引之后找3的值
  
  tup.count(value)
  len(tup)
  
  () + (1,) 返回（1）这是生成新的元组
  	
  ```

  ### (3). 字符串

+ 字符串一旦定义不可以修改，是字面常量，在python3中字符串都是Unicode类型

+ 字符串是容器，可以遍历，而且有序，通过索引遍历比较快

+ 字符串格式化

  '{:*>9.3%}'.format(1.732)  转换成百分数，并且小数点后面留3位，一共9位右对齐，其余用星号填充*

  ‘{:*>6.2f}'.format(1.732)

  '{:3.2f}'.format(1.732)  #宽度为3，但是不起作用

  '{:2}'.format(1.732)  #宽度为2但是不起作用

   '{:f}'.format(3**0.5)

  octets = [192, 168, 0, 1] 四个位置分别对应四个数，16进制各占5位2位2位
  '{:5x}{:2X}{:02X}{:02X}'.format(*octets) 

  "int:{0:d} hex:{0:#x} oct:{0:#o} bin:{0:b}".format(8) 0代表4个位置都是8，0一定要写，#表示显示0x 或0b 或0o,d代表十进制

  '{:*^5}'.format(21) 共占5位并且中间对齐，空缺位置用星号填充

  + '{}乘{}={:<04}'.format(3, 7, 3*7) 共占4位，左对齐，空缺位置用0填充

  + '{}乘*{}={:0>4}'.format(3, 7, 3乘7) 共占4位，右对齐，空缺位置用0填充

    '{}乘*{}={:>04}'.format(3, 7, 3乘7) 两种写法等效

  + Point = namedtuple('Point', 'x,y') p = Point(4,5)  "{{{0.x},{0.y}}}".format(p) 显示效果‘{4, 5}’

    "{0.x},{0.y}".format(p) 显示效果‘4, 5'

+ s.isidentifier() 判断字符串是否为标识符（字母数字下划线）

+ 查

  + s.count('very', 4, 20)

  + s.index('very', 4, 20)  s.rindex('very', 4, 20)

  + s = "Hello"   s.find('l', -3, -1) 找到第一个L,并返回索引2, find找不到会返回-1，不会报错

    s.rfind('l',-3, -1)   找到第二个L,并返回索引3

+ 改

  + s.strip() 默认去除字符串两端所有空白字符（\r \n \r\n \t \f等）

    s.strip('\r\f\n\t   ')  也可以指定需要去除的字符串，取''或''的关系, 如果指定1个空格或者2个空格，都可以去除所有空格

    s.lstrip()

    s.rstrip()

    

  + s.replace(old, new, 替换次数，不指定全部替换)

  + s.title() #每个单词首字母大写

  + s.capitalize() #单词首字母大写

  + s.swapcase() #交换大小写

  + s = "I'm\tasu\rper\r\nstu\nd\\fent\f."  s.partition('I')   #返回3元组，必须指定一个参数

    s.partition('  ')   #若字符串中没有空格，则最后用两个空格填充 partition中的参数不能是

    空字符串

  + s.splitlines()  #不能指定参数，行分隔符默认是\r\n \n \r \f 等，不包含\t制表符

    s.split() 默认拆分空白字符

    s.split('\n',maxsplit=1) 可以指定拆分次数

    s.split('I', -1)  s.rsplit('I', -1) -1代表所有的都拆分，两个结果一样

+ 增

  + "".join(["1",'2','3'])  join(可迭代对象)，并且对象本身都是字符串，返回新的字符串

  ​         也返回新的字符串

  ​		",".join(tuple(map(str, range(5)))) 需要将数字转换成字符串

  ​		

  + ‘+’ 相加的两个对象必须是字符串，并且返回新的字符串

+ 防止字符串转义 R r \

### (4). bytes

+ python3中新增加了 bytes 和bytearray

+ bytes是不可变字节，bytearray是可变字节数组

+ 一个**字节**有8位，表示0～255，共256种可能

+ x = 'abc' x是**字符**组成的有序序列，x是一个字符串，x.encode() 将字符串转换成2进制字节，x.decode()将二进制转换成字符串。

  x.encode()  = b'abc'   = b'\0x61\0x62\0x63'  =bytes('abc', 'ascii' )  第二个参数一定需要传

  ‘\x09’  回车对应‘\t’

  '\x13'    表中对应去找

  ‘\x0d\x0a’  '\r\n'       'a'.encode()  0x61

  '1'

  '\x01' 

  '\x0d0a'  '\r0a'

  + 构建bytes的方法

    bytes(range(97, 100)) 返回b'abc'(给开发人员看的) , 在计算机中存的是b'\0x61\0x62\0x63'

    bytes([97, 98, 99])   =  bytes(range(97, 100))    =   bytes('abc', 'utf-8')  =   bytes('abc', 'ascii')

    =bytes(b'abc')    =   bytes.fromhex('61 62 63')

    都返回b 'abc'(给开发人员看的) , 在计算机中存的是b'\0x61\0x62\0x63'

    bytes() 返回b''

    bytes(3) 返回b'\x00\x00\x00'

    bytes() + bytes(b'abc')  返回 b'abc'

    bytes(b'123') + bytes(b'abc')  返回 b'123abc'

  + bytes的返回值

    b'\tabc'  返回 b'\tabc'

    b'9abc'  返回 b'9abc'

    b'abc'[0]  返回10进制的97

  + 十六进制加法

    0x30 -1 = 0x2f  在计算机中的表示hex(0x30 -1)  返回字符串'0x2f'

    0x7f + 1 = 0x80  在计算机中的表示hex(0x7f + 1)  返回字符串'0x80'

    hex(127) 十进制的127转换成16进制，可以用一个字节表示（因为1个字节可以表示0～127）， 但是‘127’需要3个字节来表示，前面的几种编码都兼容了ASCII

  

+ 几种编码方式：unicode 是python 内部使用的字节编码 ，中文是2个字节一共16位，表示65536种方式，GBK编码中中文也是两个字节，utf-8中文大多数是3个字节表示（多字节编码一般用在网络编程中），ASCII中不能表示中文，编码范围是0-255
  
+ x = '中文'  y = x.encode() 默认是utf-8编码，y.decode()
  
+ 字符串与编码相关，在字节的世界只有数字

+ ASCII码表

+ 方法

  + b'abca'.replace(b'a',  b'123', 次数)

  + 'abc'.encode()  返回b'123'，如果在结果.hex(), 则返回'616263'

    'abc'.encode().hex()  =  bytes(range(97, 100)).hex()  = b'abc'.hex()

    与b'616263'.hex() 不同？？？？

  

### (5). bytearray

+ 构建bytearray

  bytearray(range(97, 100))  =   bytearray('abc', 'utf-8')    =   bytes(bytearray(b'abc'))  都返回b'abc'

  bytes(bytearray)  bytearray(bytes). 两者相互转换

+ 方法

  m = bytearray()  

  bytearray(b'abc') + bytearray(b'123') 返回 bytearray(b'abc123')

  bytearray(b'') + bytearray(b'123') 返回 bytearray(b'123')

  **bytearray后面只能添加数字 16进制或者10进制**

  m.append(0x31)  返回bytearray(b'1')

  m.extend(range(65, 67)) 返回bytearray(b'AB')

  m.strip()  去掉两侧空格，有返回值，不改变原来的m

  其他方法：m*2  pop remove  clear   等等

+ 16进制表示与字符串中的16进制表示

  0x31   回车返回49

  ‘\x31’.encode() 返回b'1'

  '\0x31'.encode() 返回b'\x00x31'    ？？？？

  

### (6). 字节序

+ 大端模式与小端模式

  

### (7). 线性结构总结

+ x[1:-1] 去头去尾

+ 索引切片可以超过上界和下界

+ x[-1, -5, -1] [start, stop-1]=[start, stop)

+ x[1: : -3]  1:空格，切片控制方向向左

+ x[-10: : -3]   同样的道理

+ y = x[:] = x[::]  与浅拷贝相同   y = x 表示引用计数加1

+ == 对于内建数据结构表示内容相同，但是对于自定义结构可能退化成表示内存地址相同

+ 通过索引更新list  

  将原列表区间替换 ，左侧是可变类型，右侧是可迭代对象

  n[1:3] = (5, 0)

  n[1:3] = [10, 11, 12]


### (8). set

+ set dictionary 都是哈希表

+ collection指定容器和集合类型，set指定集合

+ is 判断地址是否相同（也包括内容），== 只判断内容 相同

+ set 是可变的，不重复，无序的容器

+ 定义集合：空集合set(),   有元素的集合set('abc')  = set(['a', 'b', 'c']), set（可哈希对象），任何层次又不能出现

  [] bytearray set dict等。

+ set（）按内容相等去重复

+ 增 s1.add() 加一个元素，无append

  ​      s1.update(*多个set)，原地修改s1

  删 s1.remove('a')  找不到会报keyerror

  ​     s1.discard('a') 找不到也不会报错

  ​     s1.pop()  随机删除一个元素并返回

  ​     s1.clear()

  不能修改，也不能根据索引查找

+ 判断一个元素在不在集合中用in, 速度很快O（1）

+ &交集 |并集 -差集  A^B = (A-B) U (B-A)  A^=B,表示直接修改A，不加等号表示生成新的

+ 可哈希的对象：

  None  字面常量 布尔值 tuple bytes 字符串

+ 散列：一个微小的变化引起结果巨大的变化

+ 幂等性：一个可哈希对象，运行几次哈希值都相同

+ 哈希冲突：2个不同的哈希对象，对应相同的哈希值

+ 整数的哈希值：数%很大的数 = 哈希值

### (9). mapping

+ 字典的特点：无序，可变，key不重复可哈希

+ 构建空字典：{}  dict()

+ 构建字典的几种方式：

  d = dict(a=1,  b=2)  注意a,b不能是字符串

  d = dict((1,2), ['a', 4],  a=4) 可以修改a, 无a则新建，2元组结构第一个数需要可哈希

  d2 = dict(d,  a=23). 可以修改a, 无a则新建

  d = dict.fromkeys('abc',  0) 0为缺省值，不给则默认生成None

  d3 = d.setdefault('a', 1000)  无a则重新生成，有a则返回对应的value

+ 增

  d['a'] = 100   

+ 删

  d.pop('一定要有键'，如果找到键，返回要删除的键对应的值，如果没找到会keyerror，也可以填缺省值，找不到返回缺省值)

  d.popitem() 没有参数随机删除键值对，原地修改，返回删除的键值对

  def d['键']    删除原字典中的键值对，同时被删除的value，对应的值计数减1，这也是删除的本质，即

  删除标识符，并且标识符对应的对象引用计数减1，但是对象是否被引用计数清0，取决于在其他地方使用使用了该对象

+ 改

  d['a'] = 100 如果a存在于字典中，则a的值被修改为100

  d.setdefault('a',  100)  如果a存在于字典中，则返回‘a’对应的value，如果不存在，则将键值对（‘a’ : 100)加入到字典中，并且返回新加入的value100，如果不给定100，则默认值是None。

  d2.update({'a': 1, 'c':2},   a = 30,  b = []) a会被更新成30，b会新加入到d2中。

+ 查

  d['a']

  d.get('a', 缺省) 如果缺省值不填写，找不到a时返回None,  如果找打a返回对应的value

  d.setdefault('a', 缺省)  如果a存在则返回对应的value。与get不同的是，setdefault有一个修改的过程

+ 遍历

  在for 循环中有dictionary view 对象控制d.keys() d.values() d.items()   的长度不可以改变，但是值可以修改，

  d.keys()生成类似set对象，其他两种方法不可，因为里面的值不一定哈希，所以查找values里面的值时间复杂度很高。在while循环中，字典长度可以改变。

  判断一个对象是否可哈希用hash()

  



## 9.常用的函数和类

+ random模块

  random.choice(squence)

  random.shuffle(squence)

  random.randint(1, 3) #左右全包

  random.randrange(1, 3) # 左包又不包

  random.sample(squence, k=3) #只能抽取不同地址的元素，k表示采样个数，random.sample([2,2], k=2) = [2,2]

+ collections模块

  + namedtuple ：Point = namedtuple('classname', 'x   y') 第二个参数也可以是'x,y'    ['x', 'y']   ('x', 'y')

  point = Point(5, 4) 一旦定义不可以修改，若point = Point([5], [4]) ,则可以修改point.x[0] = 13, 可以通过两种方式取出里面的值point.x point[0] point.y point[1]

  + defaultdict(函数可以是str, int, list, 也可以是高阶函数)
  + OrderedDict 可以记录数据录入顺序



# 五、知识点杂记

+ 剩余内存够用不代表连续的内存够用
+ 字节码也是可以被虚拟机识别的二进制
+ js可以动态生成网页，但是消耗内存
+ 代码都放放在内存中，以便cpu使用
+ 二进制的机器语言 到cpu的指令集一定要有几行汇编语言
+ 动态语言运行时才知道变量类型，静态语言编译时就知道变量类型
+ 赋值即定义，赋值同时重新指向
+ Jupyter notebook
   + 快捷键：
   + m 切换文字
   + ‘#’后面加空格
   + ‘*’ 表示正在运行 两种停止办法
   + shift + enter 运行
   + ctrl + enter 生成新行加运行
   + a b 新建cell
   + 找个文件夹打开 jupyter notebook
   + ~/.pip/pip.conf 里面填写`[阿里云镜像](mirrors.aliyun.com)` 里面pypi
的内容
   + dd  删除单元格
   + _  下划线返回上一次输出，__两个下划线表示前2次输出
   + 可以使用 ls cd       cd-   (减号表示)上一次目录
   + _dh   可以到处切换历史
   + ！touch test.txt表示当前操作系统中的命令
   + %%timeit  语句块的时间，%timeit primenum()函数执行时间
+ 程序放在内存中分为几个进程
+ 几个核就是几个cup
+ 充分利用内存可以优化程序
+ python中大写字母一般用在类中，或者表示常量
+ python常量无法定义，但是可以以全大写字母表示常量
+ 字面常量：例如12，不可以更改，但可以通过运算生成新的常量13
+ 三引号可以表示多行字符串，也可以识别里面的单引号和双引号
+ 不要同时使用多个if if 尽量使用if elif else
+ 除法的计算量很大
+ [1,2] +[4,5]表示新生成一个列表（会单独占用空间）
+ str(任何对象都可以转换成字符串)
+ if else 判断语句如果多，对效率的影响不大，但是如果下面的交换次数多则会影响效率
+  容器与遍历互为充要条件，可以遍历的不一定有索引，但是有索引的一定可以遍历
+  reversed 函数底层实现，与倒着取索引-(i+1), 原理相同


# 六、平时练习注意事项：
+ 多查看官方文档，自己整理
+ 练习时现有基本思路，写出代码再修改
+ 自己debug, 学会单元测试，注意多线程都会在哪里出现bug
+ 在学框架之前，需要熟悉标准库

# 七、待解决的问题：
+ 8086原理？
+ 固态硬盘与硬盘？
+ 标识符与变量？
+ c =3 >5 返回false？



