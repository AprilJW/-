[TOC]

# 目录

---

**面试重点总结**

`面试中可能会遇到的题目`



# 一、面试重点总结
	线程，进程，IO
	中间件本质
	关系数据库
	web界面开发，Django源码
	数据分析：工具应用熟练，数学理论熟悉
	函数封装
	面向对象
	难点：装饰器
	数据库原理，网络原理，操作系统原理，数据结构和算法(bat)
	求10万以内质数，判断某个数是否为质数，求斐波那契数列第101项或者前都少项（递归，生成器，循环），打印菱形

# 二、面试中可能会遇到的题目
## 1.动态语言的内存管理：
    什么是垃圾回收GC？面向对象编程在内存管理方面的优势和劣势？
    在程序运行时某一些对象的引用计数（sys.getrefcount(x)）可能为0，这些对象会被打上标记，说明为空，这些对象，所占用的碎片化内存，会被整理成连续的内存空间以便后续使用，这个过程叫做垃圾回收。但是垃圾回收时内存不能使用，所以需要在空闲时间整理内存，也不需要频繁整理，看实际需要。
    引用计数增加的方式：
        对象赋值给其他变量例如：x = [1,2] y = x  列表的引用计数加
        函数调用 foo(x)  调用时增加一次，调用完成，恢复原来的次数
    引用计数减少的方式：
        函数运行结束时，局部变量会被自动消除，引用计数减少
        变量赋值给其他对象 x = 3 x = 4, 3的引用计数少一次
    另外， 字面常量的引用计数不容易判断
## 2.元编程
    可能是会拉开差距的面试题

## 3.计算机5大组成部分及各部分的功能

## 4.python语言的特点



# 三、计算机基础知识

## 1.冯诺伊曼体系
+ 计算机5大部分：输入设备，输出设备，内存，cup（包括运算器，和控制器,  寄存器，缓存器）

+ cup：做所有运算，并通过控制器来控制内存，输入输出设备

+ 内存：作为cup和IO之间的桥梁，数据需要从IO设备加载到内存，才能被
  cup使用
  
+ 内存的特点：断电易失

+ 寄存器：用来暂时存放内存中的数据，速度和cup一样快

+ 多级缓存：用来存放内存中的数据，级数越高速度越慢，存储空间越大

+ 数据流向：IO设备到内存再到cup

+ 计算机中可以存数据的结构：IO设备，内存，cup中还有寄存器和缓存器

+ 个各结构的运算速度：cup >> 内存 >> IO设备

  ![]()

## 2.解释性语言和汇编语言
+ 解释性语言工作流程：源代码被解释器翻译成Bytecode,然后在虚拟机上运行（如pvm）,转换成机器语言

+ 编译语言工作原理：源代码被编译器，直接编译成机器语言
+ 非结构化：多个入口多个出口
+ 结构化：一个入口一个出口
+ Python是多范式的面向对象，结构化，函数式编程



# 四、python基础知识及练习
## 1.进制

    0xa 十六进制
    0b1 二进制
    0o7 八进制

+ 10 进制到 其他进制 用除法取余数
+ 其他进制转10进制 对应位置累乘
+ 2进制以1结尾在10进制中都是奇数
+ 2进制与16进制相互转换容易
+ 8bits(位) = 1byte（字节）
+ 网络一般是bits，u盘一般是1byte

+ 需要记住的16进制到10进制的几个数：
        0x30 48
        0x31 49
        0x41 65
        0x61 97
        0x7F 127
  
+ 例子：
            
    1.  111 二进制
        F 十六进制      
        15 十进制

    2.  0xFF 十六进制 表示256个无符号位
        1111 1111 二进制
        2的8次幂减1 255

    3.  1000 00000 二进制
        2的7次幂 128 十进制
        0x80 十六进制

    4.  0x7F 十六进制
        0111 1111 二进制
        255-128=127 十进制

    5. int('1a', 16) = 16+10=26

## 2.按位运算
    &  位与
    |  位或
    ~  位非
    ^  位异或
+ 例子：
    1. 12的源码,补码,反码都为 0000 1100在按位取反的过程中计算机自动求了补码，～12的按位取反 为1111 0011，计算机认为这是个负数，所以又去了补码（负数的补码为，首位不变，其他位数取反码，并加1），即为1000 1100+1=1000 1101=-13

    2. -1 我们看到的格式为-0b1和1000 0001, 在计算机中的存在格式为1111 1110 + 1=1111 1111 =0xFF。所以0xFF 不仅表示正的255还表示-1 

    3. 0xFE = 0xFF-1=1111 1111 -1 = 1111 1110 = 0xFE

    4. 0xFE的补码即在计算机中的存在格式 1000 0001+1=1000 0010 =-2

    5.异或
    10^9 = 0000 1010 ^ 0000 1001 = 0000 0011=3
    10^-9 = 0000 1010 ^ (1000 1001自己看到的）1111 0110+1 =1111 1101 取补码 1000 0011=-3

## 3.逻辑运算
    逻辑元算
    and
    or
    not 

+ Or短路是指返回表达式第一个位置的值 4 or 5 or 6=4+5+6 返回6
+ and短路是指 第一个位置为0 0 and 5 and 6 =0*5*6 返回0
+ 与false等价的 4个空容器，空串，None，0
+ 运算符的优先顺序: 单目运算符> 双目算数运算符 >比较运算符 >逻辑运算符
+ 例子：
    1. (1 and 0) or (5 and 6) 返回6
    2. 0 or 'abc' 返回‘abc’

## 4.分支及循环
+ 分支： if前面的条件被跳过，后面隐含前面条件
+ If 和elif加条件和冒号 else后面直接加冒号
+ 只有一个条件可以写成 if 3<2:print('111')

+ range(a)前包后不包，是惰性对象，range?查看帮助 ，一般作为计数器，当作为计数器时a大于
+ for i in range(10, -1, -2)打印10，8，6，4，2，0
+ continue  跳过当前一次continue后面的循环，进入到下一次循环，如果当前循环是最后一次，则跳出循环

+ Break终止当前for循环或者其他循环，continue终止本次循环进入下一次循环
+ 例子：
      
    1.  ``` python
        for i in range(100):
            print(i)
            if  i > 2:
                break
            else:
            print('end')
        ```
    + 当如果循环正常执行，并且遇到了break,就认为循环不正常，不执行else(两个条件)，否则都执行else

## 5.特殊符号
+ \n 换行
+ \r 换行
+ \r\n 回车换行
+ r R 加到字符串前面表示不转义
+ \t 四个空格
+ \  在转义前面再加一个反斜杠表示不转义
+ 在字符串最后加上\ 表示不换行
+ f 表示字符串前缀，例如f'{a}, {6}' = '100, 200'

## 6.python语言的特点
+ python是动态的强类型语言，动态语言的特点是不需要事先声明变量，
  可以在使用的同时被声明，使用方便，但是也存在无法判断变量类型问题，强类型语言的特点是只有相同类型变量之间才可以操作  ，例如：python不能运算‘abc’+1, 但是在python中也存在隐式的类型转换，例如：1+0.5=1.5

  

## 7.数值类型

+ int 为长整型，无大小限制，但是受内存限制
+ bool 可以和整型直接运算
+ int 截取整数部分
+ // floored quotient 向下取整
+ math.floor() 向下 math.ceil()向上 round 4舍6入 5取偶
+ math.pi math.e math.sqrt()=2 ** 0.5 pow(2,3) math.pow(2,3) math.log2(4) math.log10(100)=2
+ min(range(5))=0 min([9,0])=0 min(3, 4, 5)=3 max用法相同
+ a = 2 , b = hex(100) 不能这么用
+ bin(100) = 0110 0100  hex(100) = 64 oct(100)=0o144
+ type(12)返回类型 isinstance('abc', (str, int, float))返回布尔

## 8. 容器

### (1). 列表

+ list 索引0-len(a)-1  -len到-1，构建list=[1,2] list=list(range(5)) list=list()

  ​	list 方法：

  ​	alst.len() 时间复杂度O(1)

  ​	alst.append() O(1)

  ​	alst.index(object, 开始索引，结束索引)  O(n) 两个索引范围前包后不包

  ​	alst.count() O(n)

  ​	alst.insert(索引，object)  在索引前面插入，超出索引插在最前面或最后面 O(n)

  ​	alst.extend([1,2]) O(1)

  ​	alst + blst 生成心列表，开劈新空间   **注意**

  ​	alst*5 对当前列表里面的元素操作，例如：[[2,3]乘5]=[[2,3,2,3,2,3,2,3]]生成新列表，开辟新空间，**注意**

  ​	alst.sort(*, key=None, reverse=False) 可选参数和必须写的关键字参数，没生成新的，原地排序，sort有时必须要用，但是少用。例子：

  ```python 
  alst=[1,2,'a']
  #在排序的过程中会转换成字符串，但不改变原来的结果
  alst.sort(key=str)
  #不可以用????
  alst.sort(key=int)
  
  ```

  alst.remove(object) 找不到会报错，会删除第一个找到的object，因为需要先找到再删除，而且需要挪位置，所以效率很低, O(n)

  alst.pop()

  alst.clear()  引用计数标记为0

  修改列表

  ```python
  a = [1,2,3]*2
  a = [1,2,3,1,2,3]
  a[1] = 31
  a = [1,31,3,1,2,3]
  
  # 相乘后a两个位置的元素具有相同地址
  a = [[1,2,3]]*2
  a = [[1,2,3], [1,2,3]]
  a[1][2] = 31
  a = [[1,2,31], [1,2,31]]
  
  #a两个位置元素具有不同地址
  a = [[1,2,3], [1,2,3]]
  a[1][2] = 31
  a = [[1,2,3], [1,2,31]]
  
  #a与b的值相等即 a==b,但是地址不同 copy之后id(a) != id(b), id(a[1])=id(b[1])
  a = [[1,2,3], [1,2,3]]
  b = a.copy()
  a[1][2] = 31
  a = [[1,2,3], [1,2,31]]
  b = [[1,2,3], [1,2,31]]
  
  #a与b的值相等及 a==b, deepcopy之后id(a) != id(b), id(a[1]) != id(b[1])
  a = [[1,2,3], [1,2,3]]
  b = copy.deepcopy()
  a[1][2] = 31
  a = [[1,2,3], [1,2,31]]
  b = [[1,2,3], [1,2,3]]
  
  
  ```

  ![浅拷贝图示](/Users/jw/Projects/python23/magedu/shallowcopy.png)

  

  

  in  O(n)不要经常用

  als.reverse() 通过对调实现的，一般不用，只需要倒着打印即可

   

  ​	在jupyter notebook里面五out无返回值

+ 链表Linkedlist

+ 栈stack 后进先出

+ 队列queue 先进先出

+ 比较：列表查找很快，因为有索引，但是需要连续的内存空间，插入和删除很慢，两个方向都可以操作；链表因为没有索引，所以查找元素需要从头查找速度慢，但是插入和删除很快，两个方向都可以操作；栈一般用作处理后进后出的数据，一般不做插入删除和索引和计算长度的操作；队列一般用作处理先进先出的数据，一般不做插入删除和索引和计算长度的操作，栈和队列是基于列表和链表实现，以上4种都是顺序线性结构。

  

  ### (2). 元组

  新建元组，() (1,) (1,2)   tuple()

  ​	元组不可以修改：是指里面的值和地址不能修改

  ​	修改元组

  ```python
  tup =(1, (2,3),[4,5,'a',(4,)])
  tup[0] = 31 #不可以修改
  tup[1][1] = 31 #不可以修改
  tup[2][1] = 31 #可以修改
  tup[2][3] = 31 #可以修改
  tup[2][3][0] = #不可以修改
  
  tup = (1,)*3
  tup = (1, 1, 1)
  
  tup = ((1,),)*3
  tup = ((1), (1), (1))
  #tup不可以修改
  
  tup = ([1])*3
  tup = ([1], [1], [1])
  tup[1][0] = 100
  tup = ([100], [100], [100])
  
  tup.index(value, [start, [stop]])
  tup = (1,2,3,4,5,5,4,3)
  tup.index(3, 5) #从第5个索引之后找3的值
  
  tup.count(value)
  len(tup)
  
  () + (1,) 返回（1）这是生成新的元组
  	
  ```

  ### 

### (3). 字符串

+ 字符串一旦定义不可以修改，是字面常量，在python3中字符串都是Unicode类型

+ 字符串是容器，可以遍历，而且有序，通过索引遍历比较快

+ 字符串格式化

  '{:星号>9.3%}'.format(1.732)  转换成百分数，并且小数点后面留3位，一共9位右对齐，其余用星号填充*

  ‘{:*>6.2f}'.format(1.732)

  '{:3.2f}'.format(1.732)  #宽度为3，但是不起作用

  '{:2}'.format(1.732)  #宽度为2但是不起作用

   '{:f}'.format(3**0.5)

  octets = [192, 168, 0, 1] 四个位置分别对应四个数，16进制各占5位2位2位
  '{:5x}{:2X}{:02X}{:02X}'.format(*octets) 

  "int:{0:d} hex:{0:#x} oct:{0:#o} bin:{0:b}".format(8) 0代表4个位置都是8，0一定要写，#表示显示0x 或0b 或0o,d代表十进制

  '{:*^5}'.format(21) 共占5位并且中间对齐，空缺位置用星号填充

  + '{}乘{}={:<04}'.format(3, 7, 3*7) 共占4位，左对齐，空缺位置用0填充

  + '{}乘*{}={:0>4}'.format(3, 7, 3乘7) 共占4位，右对齐，空缺位置用0填充

    '{}乘*{}={:>04}'.format(3, 7, 3乘7) 两种写法等效

  + Point = namedtuple('Point', 'x,y') p = Point(4,5)  "{{{0.x},{0.y}}}".format(p) 显示效果‘{4, 5}’

    "{0.x},{0.y}".format(p) 显示效果‘4, 5'

+ s.isidentifier() 判断字符串是否为标识符（字母数字下划线）

+ 查

  + s.count('very', 4, 20)

  + s.index('very', 4, 20)  s.rindex('very', 4, 20)

  + s = "Hello"   s.find('l', -3, -1) 找到第一个L,并返回索引2, find找不到会返回-1，不会报错

    s.rfind('l',-3, -1)   找到第二个L,并返回索引3

+ 改

  + s.strip() 默认去除字符串两端所有空白字符（\r \n \r\n \t \f等）

    s.strip('\r\f\n\t   ')  也可以指定需要去除的字符串，取''或''的关系, 如果指定1个空格或者2个空格，都可以去除所有空格

    s.lstrip()

    s.rstrip()

    

  + s.replace(old, new, 替换次数，不指定全部替换)

  + s.title() #每个单词首字母大写

  + s.capitalize() #单词首字母大写

  + s.swapcase() #交换大小写

  + s = "I'm\tasu\rper\r\nstu\nd\\fent\f."  s.partition('I')   #返回3元组，必须指定一个参数

    s.partition('空格')   #若字符串中没有空格，则最后用两个空格填充 ，partition中的参数不能是

    空字符串

  + s.splitlines()  #不能指定参数，行分隔符默认是\r\n \n \r \f 等，不包含\t制表符

    s.split() 默认拆分空白字符

    s.split('\n',maxsplit=1) 可以指定拆分次数

    s.split('I', -1)  s.rsplit('I', -1) -1代表所有的都拆分，两个结果一样

+ 增

  + "".join(["1",'2','3'])  join(可迭代对象)，并且对象本身都是字符串，返回新的字符串

  ​         也返回新的字符串

  ​		",".join(tuple(map(str, range(5)))) 需要将数字转换成字符串

  ​		

  + ‘+’ 相加的两个对象必须是字符串，并且返回新的字符串

+ 防止字符串转义 R r \

### (4). bytes



+ python3中新增加了 bytes 和bytearray

+ bytes是不可变字节，bytearray是可变字节数组

+ 一个**字节**有8位，表示0～255，共256种可能

+ x = 'abc' x是**字符**组成的有序序列，x是一个字符串，x.encode() 将字符串转换成2进制字节，x.decode()将二进制转换成字符串。

  x.encode()  = b'abc'   = b'\0x61\0x62\0x63'  =bytes('abc', 'ascii' )  第二个参数一定需要传

  ‘\x09’  回车对应‘\t’

  '\x13'    表中对应去找

  ‘\x0d\x0a’  '\r\n'       'a'.encode()  0x61

  '1'

  '\x01' 

  '\x0d0a'  '\r0a'

  + 构建bytes的方法

    bytes(range(97, 100)) 返回b'abc'(给开发人员看的) , 在计算机中存的是b'\0x61\0x62\0x63'

    bytes([97, 98, 99])   =  bytes(range(97, 100))    =   bytes('abc', 'utf-8')  =   bytes('abc', 'ascii')

    =bytes(b'abc')    =   bytes.fromhex('61 62 63')

    都返回b 'abc'(给开发人员看的) , 在计算机中存的是b'\0x61\0x62\0x63'

    bytes() 返回b''

    bytes(3) 返回b'\x00\x00\x00'

    bytes() + bytes(b'abc')  返回 b'abc'

    bytes(b'123') + bytes(b'abc')  返回 b'123abc'

  + bytes的返回值

    b'\tabc'  返回 b'\tabc'

    b'9abc'  返回 b'9abc'

    b'abc'[0]  返回10进制的97

  + 十六进制加法

    0x30 -1 = 0x2f  在计算机中的表示hex(0x30 -1)  返回字符串'0x2f'

    0x7f + 1 = 0x80  在计算机中的表示hex(0x7f + 1)  返回字符串'0x80'

    hex(127) 十进制的127转换成16进制，可以用一个字节表示（因为1个字节可以表示0～127）， 但是‘127’需要3个字节来表示，前面的几种编码都兼容了ASCII

  

+ 几种编码方式：unicode 是python 内部使用的字节编码 ，中文是2个字节一共16位，表示65536种方式，GBK编码中中文也是两个字节，utf-8中文大多数是3个字节表示（多字节编码一般用在网络编程中），ASCII中不能表示中文，编码范围是0-255
  
+ x = '中文'  y = x.encode() 默认是utf-8编码，y.decode()
  
+ 字符串与编码相关，在字节的世界只有数字

+ ASCII码表

  ![](/Users/jw/Projects/python23/magedu/ascii.png) 

+ 方法

  + b'abca'.replace(b'a',  b'123', 次数)

  + 'abc'.encode()  返回b'123'，如果在结果.hex(), 则返回'616263'

    'abc'.encode().hex()  =  bytes(range(97, 100)).hex()  = b'abc'.hex()

    与b'616263'.hex() 不同？？？？

  

### (5). bytearray

+ 构建bytearray

  bytearray(range(97, 100))  =   bytearray('abc', 'utf-8')    =   bytes(bytearray(b'abc'))  都返回b'abc'

  bytes(bytearray)  bytearray(bytes). 两者相互转换

+ 方法

  m = bytearray()  

  bytearray(b'abc') + bytearray(b'123') 返回 bytearray(b'abc123')

  bytearray(b'') + bytearray(b'123') 返回 bytearray(b'123')

  **bytearray后面只能添加数字 16进制或者10进制**

  m.append(0x31)  返回bytearray(b'1')

  m.extend(range(65, 67)) 返回bytearray(b'AB')

  m.strip()  去掉两侧空格，有返回值，不改变原来的m

  其他方法：m*2  pop remove  clear   等等

+ 16进制表示与字符串中的16进制表示

  0x31   回车返回49

  ‘\x31’.encode() 返回b'1'

  '\0x31'.encode() 返回b'\x00x31'    ？？？？

  

### (6). 字节序

+ 大端模式与小端模式

  

### (7). 线性结构总结

+ x[1:-1] 去头去尾

+ 索引切片可以超过上界和下界

+ x[-1, -5, -1] [start, stop-1]=[start, stop)

+ x[1: : -3]  1:空格，切片控制方向向左

+ x[-10: : -3]   同样的道理

+ y = x[:] = x[::]  与浅拷贝相同   y = x 表示引用计数加1

+ == 对于内建数据结构表示内容相同，但是对于自定义结构可能退化成表示内存地址相同

+ 通过索引更新list  

  将原列表区间替换 ，左侧是可变类型，右侧是可迭代对象

  n[1:3] = (5, 0)

  n[1:3] = [10, 11, 12]


### (8). set

+ set ，dictionary 都是哈希表，set不能修改，也不能根据索引查找

+ collection指定容器和集合类型，set指定集合

+ is 判断地址是否相同（也包括内容），== 只判断内容 相同

+ set 是可变的，不重复，无序的容器

+ 定义集合：空集合set(),   有元素的集合set('abc')  = set(['a', 'b', 'c']), set（可哈希对象），任何层次又不能出现

  [] bytearray set dict等。

+ set（）按内容相等去重复

+ 增 s1.add() 加一个元素，无append

  ​      s1.update(*多个set)，原地修改s1

  删 s1.remove('a')  找不到会报keyerror

  ​     s1.discard('a') 找不到也不会报错, 返回None，只有一个参数，没有缺省参数

  ​     s1.pop()  随机删除一个元素并返回, 如果是空集合则返回keyerror

  ​     s1.clear()

+ 判断一个元素在不在集合中用in, 速度很快O（1）

+ &交集 |并集 -差集  A^B = (A-B) U (B-A) ，对称差集， A^=B,表示直接修改A，不加等号表示生成新的

+ 可哈希的对象：

  None  字面常量 布尔值 tuple bytes 字符串

+ 散列：一个微小的变化引起结果巨大的变化

+ 幂等性：一个可哈希对象，运行几次哈希值都相同

+ 哈希冲突：2个不同的哈希对象，对应相同的哈希值

+ 整数的哈希值：数%很大的数 再通过某些映射成很大的   哈希值, 哈希值再对应内存中的地址

### (9). mapping

+ 字典的特点：无序，可变，key不重复可哈希

+ Python3.6之后有一个OrderDict，可以记录录入顺序，但是不同排序。

+ 构建空字典：{}  dict()

+ 构建字典的几种方式：

  d = dict(a=1,  b=2)  **注意a,b不能是字符串**

  d = dict((1,2), ['a', 4],  a=4) 可以修改a, 无a则新建，2元组结构第一个数需要可哈希, 

  **注意a ,b 需要的字符串 **

  d2 = dict(d,  a=23). 可以修改a, 无a则新建

  d = dict.fromkeys('abc',  0) 0为缺省值，不给则默认生成None

  d3 = d.setdefault('a', 1000)  无a则重新生成，有a则返回对应的value

  d.update(*键值对)

+ 增

  d['a'] = 100   

+ 删

  **注意：没有remove 方法**

  d.pop('一定要有键'，如果找到键，返回要删除的键对应的值，如果没找到会keyerror，也可以填缺省值，找不到返回缺省值)

  d.popitem() 没有参数随机删除键值对，原地修改，返回删除的键值对

  def d['键']    删除原字典中的键值对，同时被删除的value，对应的值计数减1，这也是删除的本质，即

  删除标识符，并且标识符对应的对象引用计数减1，但是对象是否被引用计数清0，取决于在其他地方使用使用了该对象

  d.clear()

+ 改

  d['a'] = 100 如果a存在于字典中，则a的值被修改为100

  d.setdefault('a',  100)  如果a存在于字典中，则返回‘a’对应的value，如果不存在，则将键值对（‘a’ : 100)加入到字典中，并且返回新加入的value100，如果不给定100，则默认值是None。

  d2.update({'a': 1, 'c':2},   a = 30,  b = []) a会被更新成30，b会新加入到d2中。

+ 查

  d['a']

  d.get('a', 缺省) 如果缺省值不填写，找不到a时返回None,  如果找不到a返回对应的value

  d.setdefault('a', 缺省)  如果a存在则返回对应的value。与get不同的是，setdefault有一个修改的过程

+ 遍历有3种方法

  在for 循环中有dictionary view 对象控制d.keys() d.values() d.items()   的长度不可以改变，但是值可以修改，

  d.keys()生成类似set对象，其他两种方法不可，因为里面的值不一定哈希，所以查找values里面的值时间复杂度很高。在while循环中，字典长度可以改变。

  怎么删除呢？ 可以先放到列表里再删除

  d.keys() d.items()  都可以进行集合之间的运算
  
  判断一个对象是否可哈希用hash()
  

### (10). 16进制、字节等类型转换

![](/Users/jw/Projects/python23/magedu/python各个类型转换.png)





### (11). 解析式与迭代器

字典，集合，列表等的解析式，一般用来构建数据，如果if else比较多，不适合用推导式

生成器不可以使用len（）函数，因为不确定里面有多少个元素。

#### 11.1 列表推导式（解析式）

a = [表达式   for i  in range(10) if i %2 == 0 or i % 3 == 0]

a =  [表达式   for i  in range(10) if i %2 == 0 and i % 3 == 0]

a =  [表达式   for i  in range(10) if i %2 == 0  if  i % 3 == 0]

a = [(i, j)  for i  in range(3)  for j in 'abc']

2与3的结果一样，都是同时是被2，3整除的数  两个if或者for相当于两次右斜,  表达式可以是函数等多种形式

[(i,j)  for i in range(7)  if i >4 for j in range(20, 25) if j >23]   都返回两个结果，但是第一种方法会快一点儿

[(i,j)  for i in range(7)    for j in range(20, 25) if j >23  if i >4]

#### 11.2 字典和集合推导式

字典与集合的区别是前面表达式有没有冒号，**推到式前面的表达式一定需要有返回值**，例如：print（）[].append() 都不能作为推到式前面的表达式

{i : str(j)  for i in 'abc'   for j  in range(3)}   因为字典的键不能重复，所以最后只生成3个字典元素

{(i str(j))  for i in 'abc'   for j  in range(3)}  包含生成的6个元祖的集合

{{i : str(j)}  for i in 'abc'   for j  in range(3)}  集合中的元素必须可哈希

{[i : str(j) ] for i in 'abc'   for j  in range(3)} 

#### 11.3 生成器迭代器总结

将列表推导式的方括号改成圆括号就变成生成器，生成器里面的值可以通过的for循环，next（）方法，list（），set（）方法取出，但是for循环可以取出生成器里面的所有元素，next()方法每次只能取出一个，当取出最后一个元素时，如果再调用next（）方法会报错，不过可以通过添加缺省值的方式返回，生成器只能用一次，如果再次需要，只能重新构造。生成器与迭代器和迭代对象有一定的差别，生成器包含于迭代器，迭代器包含于迭代对象。

例如：range()函数是可迭代对象，但不是迭代器，zip()函数是迭代器，但不是生成器，如果想构造迭代器，只需要在可迭代对象外面加上iter()函数即可。

#### 11.4 列表表达式与生成器的比较

列表表达式一次生成全部对象，返回新的列表，生成器是返回生成器对象，这是个惰性对象，驱动一次返回一个元素，列表表达式因为一次性生成全部元素，所以从单次返回值来看，很占内存空间，生成器表达式更节约空间，如果生成器里面没有元素几乎不占内存空间，从总的空间来看，列表表达式与生成器表达式所占用的空间相近。生成器表达式的计算时间短，列表解析式时间长。



## 9.常用的模块

+ random模块

  random.choice(squence)

  random.shuffle(squence)

  random.randint(1, 3) #左右全包

  random.randrange(1, 3) # 左包又不包

  random.sample(squence, k=3) #只能抽取不同地址的元素，k表示采样个数，random.sample([2,2], k=2) = [2,2]

+ collections模块

  + namedtuple ：Point = namedtuple('classname', 'x   y') 第二个参数也可以是'x,y'    ['x', 'y']   ('x', 'y')

  point = Point(5, 4) 一旦定义不可以修改，若point = Point([5], [4]) ,则可以修改point.x[0] = 13, 可以通过两种方式取出里面的值point.x point[0] point.y point[1]

  + defaultdict(函数可以是str, int, list, 也可以是高阶函数)
  + OrderedDict 可以记录数据录入顺序

+ datetime

  datetime.datetime.now()= datetime.datetime.today()   datetime.datetime.utnow()   now会多出8小时

  d1.timestamp()  从1970.1.1到目前的时间戳，是一个具体数值，但不是时间对象，单位是s, 精确到小数点后

  6位，到us

  + 创建时间对象的2种方法：

    datetime.datetime(按格式填写)

    datetime.datetime.fromtimestamp(时间戳)

  + 可以取出d1.date  d1.month  d1.isoweekday()   d1.replace(month=12 d1.isocalendar() 等等

  + 思考：已知现在的时间求2年前的时间？

  + 格式化时间：

    datetime.strptime('20180612 12:23:45',   '%Y/%m%d   %H:%M:%S')

    '{:%Y/%m/%d   %H:%M:%S }'.format(d1)

  + datetime.timedelta

    datetime对象  1  timedelta  2

    1 - 1 = 2

    1 + 1 = 错误

    1 + 2 = 1

    datetime.timedelta(day=5) 参数可以选

+ time  time.sleep(5) 阻塞当前线程10秒

## 10.内建函数

+ divmod(10, 3)  同时返回商和模（余数）

+ chr(20013), chr(97) 生成结果为字符，传入的参数需要是unicode编码

+ ord('中'), ord('a')  生成的结果为unicode编码

+ sorted( [1, 2, 3, 'a'], reverse = True, key=str)   内部使用高阶函数，效率高，转换时需要将元素转换成字符串

  先比较，最后但是不改变最后元素的类型

  可以排序字典：sorted({'b':1,  'a':2})    也可排序集合sorted({'b',  'a'})  ，字典和集合虽然无序但是可以给其排序

+ reversed（序列）或者reversed（range(10)） 可传入迭代器，reversed（）函数使用需要的两个条件，一是需要序列，二是需要知道长度。例如：reversed((0,1,2))  生成一个新的包含元组的迭代器，reversed（g），里面不能放生成器或者迭代器，因为不知道长度。

  **字符串反转**

  "".join((i for i in reversed('abc')))  效率高

  类似于：

  str1 = ''

  for i  in range(len('abc')):

  ​	str1  +=  'abc'[-(i+1)]	

+ zip(), 传入两个可迭代对象，取长度小的一个

  dict（zip(d1.keys(), d1.values())）给dict传入键值对

+ enumerate（）传入可迭代对象

+ iter()  生成迭代器

+ callable（函数名字不加括号），判断函数是否可以调用

## 11. 函数

+ 函数定义：

  + 函数名字不能和关键字重复，如果和内建函数重复则会覆盖原函数，名字只能由数字字母下划线组成，不能以数字开头，名字是一个标识符。

  + 参数列表，参数是形式上的参数，简称形参。

    + 形参包括：位置参数，关键字参数，可变位置参数，可变关键字参数，keyword_only参数，共5种

    + 函数调用时只能传位置参数和关键字参数，即实参

    + 函数定义时，可以同时存在着几种参数

    + 位置参数与关键字参数同时使用：

      例如：

      def   add(a, b=5):

      ​	print(a + b)

      不可以这么使用：def add(a=4,  b) 或者add(4, a=5) (a被赋值了两次)也不能这么定义，**位置参数需要在关键字参数之前**

      可以这么使用 add(4), 为缺省参数

    + 可变位置参数：z以**元组的方式传入**，不可以修改，因为本例为求和，所以如果传人range(10), 或者[1,2,3,], 传入的是这种样式（range(10),）([1, 2, 3], ),不可相加。调用时不能传关键字参数，只能传位置参数。

      例如：def sum(*z):

      ​				s = 0

      ​				for i in z:

      ​					s += z	

    + 可变关键字参数：kwargs以字典的方式传入，可以传入test(a = 1, b=2), 如果写成这种样式test(kwargs = {'a': 1, 'b': 2}), kwargs将作为单独的key, {'a': 1, 'b': 2}将作为value,一般不这么用

      调用时只能使用关键字参数

      def  test(**kwargs):

      ​	print(kwargs)

    + 可变位置参数和可变关键字参数个数范围都是0～n

    + keyword_only参数：

      ‘*’，后面的位置参数，需要通过关键字参数传递，如果有多个keyword_only参数, 参数的位置可以不按位置参数和关键字参数的顺序。‘**’kwargs后面不可以接keyword_only参数。

      keyword_only的使用场景：def fn(x, y, *, m)想要keyword_only, 但是不想要星m, def fn(x, y, *m)

    + 5大参数总结：

      def fn(x, y, z=100, *args, n, m=0, o, **kargs)

      (1). n, m, o只能通过关键字参数传入

      (2).  如果传入5个参数，x,  y, z会先占用3个，z虽然是关键字参数但是也会占一个

      (3).  x, y, z可以通过位置传也可以通过关键字传，但是关键字参数必须在位置参数之后。

  + ：后面需要加语句块，注释不算语句块

  + 不加return返回None == return None==return，函数只能返回一个值，一个数值或一个元组等容器

  + 在函数中，for  循环后面如果有return，并且执行了，则外面的else，不执行

    

+ 函数调用：

  + add()  后面需要加（），里面的参数为实参

  + print（add）只打印表示标识符，标识符指向函数，并且打印出地址。

    

+ 函数解构：

  

  ```python
  def add(x, y):
  	print(x + y)
   
  add(*{7, 8})
  add(*{'a':7, 'b':8})  #打印字符串‘ab',只取出keys,并且满足OrderDict
  add(**{'x':7, 'y':8})  #里面只能keys只能是x和y, 相当于传入了add(x=7, y=8)
  add(*{'x':7, 'y':8}.values()) #打印15
  ```

  ```python
  def add(x, y, *z):
    print(x, y, z)
    
  add(*[1, 2, 3, 4, 5])  #x 1  y 2  z是一个元组（3，4，5）
  add(*range(6)) #z是一个元组（2，3，4，5）
  ```

  

+ 函数作用阈

  + 函数或者类内部的区域称为局部或者本地作用域，内部变量称为局部变量，局部变量外部不可见

  + 函数或者类外部的区域称为全局作用域，外部变量称为全局变量，全局变量内部可见。

  + 每个函数的函数都用自己单独的作用域，变量不能共用，但是对于嵌套函数，内部函数可以使用外部函数的变量

    例子：inner，先打印‘a’, 97    outer,打印‘A’，65，因为外面的o看不到里面的小o,  所以还保持原来的65

    ```python
    # exmple1
    def outer():
      o = 65
      def inner():
        o = 97
        print('inner:', chr(o), o)
      inner()
      print('outer:', chr(o), o)
      
      
    # inner, 'a', 97
    # outer, 'A', 65
    ```

    ```python
    # exmple2
    def outer():
      o = 65
      def inner():
        global o
        o = 97
        print('inner:', chr(o), o)
      inner()
      print('outer:', chr(o), o)
    
    # inner, 'a', 97
    # outer, 'a', 97
    ```

    

    python赋值语句的注意事项：

    在本例子中会报错，找不到x, 因为赋值即定义（在函数定义时，已经解释了语句 x += 1, 所以左侧的x被重新定义成局部变量）

    ```python
    x = 5
    def test():
      x += 1 # x = x + 1
      print(x)
    ```

    解决上诉问题的方法：

    ```python
    x = 5
    def test():
      global x  #x不可以被定义为局部变量 
      x += 1 # x = x + 1
      print(x)
    ```

    打印x则为100

    ```python
    x = 5
    def test():
      global x  #x不可以被定义为局部变量 
      x = 100
      x += 1 # x = x + 1
      print(x)
    print(x)
    
    # 101, 101
    ```

    

# 五、知识点杂记

+ 剩余内存够用不代表连续的内存够用
+ 字节码也是可以被虚拟机识别的二进制
+ js可以动态生成网页，但是消耗内存
+ 代码都放放在内存中，以便cpu使用
+ 二进制的机器语言 到cpu的指令集一定要有几行汇编语言
+ 动态语言运行时才知道变量类型，静态语言编译时就知道变量类型
+ 赋值即定义，赋值同时重新指向
+ Jupyter notebook
   + 快捷键：
   + m 切换文字
   + ‘#’后面加空格
   + ‘*’ 表示正在运行 两种停止办法
   + shift + enter 运行
   + ctrl + enter 生成新行加运行
   + a b 新建cell
   + 找个文件夹打开 jupyter notebook
   + ~/.pip/pip.conf 里面填写`[阿里云镜像](mirrors.aliyun.com)` 里面pypi
的内容
   + dd  删除单元格
   + _  下划线返回上一次输出，__两个下划线表示前2次输出
   + 可以使用 ls cd       cd-   (减号表示)上一次目录
   + _dh   可以到处切换历史
   + ！touch test.txt表示当前操作系统中的命令
   + %%timeit  语句块的时间，%timeit primenum()函数执行时间
+ 程序放在内存中分为几个进程
+ 几个核就是几个cup
+ 充分利用内存可以优化程序
+ python中大写字母一般用在类中，或者表示常量
+ python常量无法定义，但是可以以全大写字母表示常量
+ 字面常量：例如12，不可以更改，但可以通过运算生成新的常量13
+ 三引号可以表示多行字符串，也可以识别里面的单引号和双引号
+ 不要同时使用多个if if 尽量使用if elif else
+ 除法的计算量很大
+ [1,2] +[4,5]表示新生成一个列表（会单独占用空间）
+ str(任何对象都可以转换成字符串)
+ if else 判断语句如果多，对效率的影响不大，但是如果下面的交换次数多则会影响效率
+  容器与遍历互为充要条件，可以遍历的不一定有索引，但是有索引的一定可以遍历
+  reversed 函数底层实现，与倒着取索引-(i+1), 原理相同


# 六、平时练习注意事项：
+ 多查看官方文档，自己整理
+ 练习时现有基本思路，写出代码再修改
+ 自己debug, 学会单元测试，注意多线程都会在哪里出现bug
+ 在学框架之前，需要熟悉标准库

# 七、待解决的问题：
+ 8086原理？
+ 固态硬盘与硬盘？
+ 标识符与变量？
+ c =3 >5 返回false？



