

## 语言分类：

### 面向机器

机器容易理解的语言，是一些机器指令，代表有汇编语言

### 面向过程

做一件事情，按步骤实现，第一步做什么，第二步做什么，如果情况A出现怎么处理，情况B处理怎么处理。适用问题规模小，可以按步骤实现，代表C语言

### 面向对象OOP

**5\***

是一种认识世界、分析世界的方法论。将万事万物抽象成为各种对象。

适用问题规模大，复杂的情况，代表C++、Java、Python

类class是一个**抽象**的概念

对象object，实例instance，都是一个实体，是个**具体**的概念

数据类，对应属性；动作类，操作类，行为，对应方法，类是对数据和操作的封装。

类中方法也是属性

表达式又名解析式，用来构建list，set,  dict, 比for循环效率高，使用列表表达式会立即生成新列表，占用大量的内存和cup；生成器的构建方式有生成器表达式，或者在函数中使用yield关键字，生成器是一个惰性对象，不会立即占用大量内存和cup，可以通过for循环和next方法获得里面的元素，生成器是一种迭代器。

### 面向对象3要素

**5\***

1.封装

第一，将属性和方法封装

第二，将数据和操作适当暴露给客户，对外提供一些接口, 该隐藏的隐藏，暴露的方法有property中的getter，setter方法. 可以用装饰器实现，也可以自己写函数加到property实例中；隐藏的方法有在属性和方法前面加一个下划线或者两个下划线

2.继承

分为单一继承和多继承，父类的属性和方法可以直接继承过来，

尽量多继承，不要在父类上改写，尽量自己写,OCP开闭原则

3.多态

面向对象编程最灵活的地方，动态绑定，同一个方法在，不同的类型上

表现不同。例如继承自动物类的人类、猫类的操作'吃'方法不同

## python中的面向对象

定义：类名大驼峰（标识符），class关键字，定义后产生类对象，绑定到标识符上。

```python
class ClassName:
	语句块
```

```python
#实例化的真实过程，先调用了类的 obj = MyClass.__new__()
#然后调用了obj.__init__()方法，但是__init__()的返回值只能是None，
#内部做了优化所以，实例化之后返回一个对象，每次实例化都走一次__init__
#实例化与初始化
#先实例化再初始化
#__init__称为初始化，出厂配置，构造器，构造方法，dunder方法
```

```python
#类属性与类方法
#类属性与类方法本质上都是类属性
#类方法method，就是函数，可以通过类标识符.函数名，访问这个属性
#点号，就是成员访问符
```

普通方法，类方法，静态方法

例子：

```python
lass Path:
    def __init__(self):
        self.name = 'tom'

    def method(self, m):  #普通方法，需要2个参数，类调用时不会注入第一参数，实例调用时，
        # 会将实例自身作为第一参数注入。
        print('普通方法：', self, m)

    @classmethod
    def class_method(cls, b):  #类方法，无论类调用还是实例调用，都会将类作为第一参数注入
        print('class method ：', cls, b)

    @staticmethod  #(用的少)静态方法, 无论类调用还是实例调用，都不会注入第一参数
    def static_method(b, a):
        print('static method ：', b, a)

# 普通方法例子
print(Path.method) #<function Path.method
print(Path().method) #bound method
Path().method(18) #实例调用时，第一参数为实例
Path.method('tom', 18) #类调用时，第一参数可以随便给一个值

#类方法例子
Path.class_method('tom')  #第一参数都为类，函数里面只要遇到self,就都是类
Path().class_method('tom')  #第一参数都为类

#静态方法
Path.static_method('11', '22')  #第一参数都不注入，需要传入两个参数
Path.static_method('11', '22')  #第一参数都不注入，需要传入两个参数

```

类对象与实例对象的\__class__  \_\_name\_\_ \_\_dict__

```python
class Person:
    height = 170

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def getage(self):
        print(self.name, __class__.__name__, self.__class__.__name__,type(self).__name__)
        # 后3种都可以取到类的__name__

pclass = Person
pinstance = Person('Tom', 18)

# __name__
pclass.__name__  # Person, 只有类可以取到名字，实例如果不定义取不到name

# __class__
pclass.__class__  # type
pinstance.__class__  # Person

# __dict___
pclass.__dict__  # {'height': 170 , '__init__':  ,'getage':,  '__doc__': }
pinstance.__dict__  # {'name': 'tom', 'age': 18}

print(*Person.__dict__.items(), sep='\n') #查看当前类的所有，__dict__

```

函数与类中出现+=比较

```python
class Person:
  height = 170
  def __init__(self, name, age):
    self.name = name
    self.age = age

p = Person('tom', 12)
p.height += 10 # 不会报错,不会走__init__，只会到类中去找height属性
p.height

def f():
    a = 10
    def f1():
        a += 1
        print(a)
    return f1
# f()()  报错

# 另一些例子
class Person:    
    def __init__(self, name, age=18):
        self.name = name
        self.age = age
        
    def growup(self, i=1):
        self.age += i
        print(self.age)
        
    def growup1(self, i=1):
        i += 1
        print('i', i)
        
    a = 1    
    def growup2(self):
        __class__.a += 1
        print('a', __class__.a)
    
    b = 2
    def growup3(self):
        b += 1
        
p = Person('tom')
p.growup()
p.growup1()
p.growup2()
p.growup3() #会报错
```

访问控制：私有，公有，protected

+ self.\_\_age = 1 私有属性，只能**类**中使用_Person.__age, 当前类名加私有属性名，**实例**不可以访问_
+ _self.\_age = 1 protected保护的属性，名字还是_age, 可以访问和修改
+ self.age = 1 公有属性
+ 同样适用于类的方法，分为私用，保护，公有方法，因为
  method也是一种属性



属性装饰器

```python
class Person:
    def __init__(self):
        self.__eyecolor = 'blue'

    @property
    def eyecolor(self):
        return self.__eyecolor

    @eyecolor.setter
    def eyecolor(self, value):
        self.__eyecolor = value

    @eyecolor.deleter # 用的不多
    def eyecolor(self):
        del self.__eyecolor

p = Person()
print(p.__dict__['_Person__eyecolor'])

#p.__eyecolor #访问不到
print(p.eyecolor) #eyecolor函数可以，当作属性来用
p.eyecolor = 'yellow' #修改属性，如果这个属性是只度模式，则不用写下面的settern和deleter方法
del p.eyecolor

# 与上面的方法类似
class Person:
    def __init__(self):
        self.__eyecolor = 'blue'

    def geteyecolor(self): return self.__eyecolor

    def seteyecolor(self, value): self.__eyecolor = value

    def deleyecolor(self): del self.__eyecolor

    eyecolor = property(geteyecolor, seteyecolor, deleyecolor, "I'm the 'eyecolor' property.")

p = Person()
print(p.geteyecolor()) #需要加括号
p.seteyecolor('yellow')
print(p.geteyecolor())
```

构造器与析构器

```python
class Person:
    def __init__(self, name): #构造器，构造函数，资源申请
        self.name = name

    def __del__(self): #析构器，构造函数,资源释放
        print('del instance', self)

def test():
    p = Person('tom')
    del p   #del x 并不直接调用 x.__del__() --- 前者会将 x 的引用计数减一，而后者仅会在 x 的引用计数变为零时被调用
    # 即在函数程序执行过程中引用计数变成0，调用了__del__
    print('*' * 10)
test()  # 执行完函数，不会打印：del instance <__main__.Person object at 0x10236c588>
# 因为在函数内部类对象的引用计数已经被清0了，会在*好上面打印，其作用的是def

def test():
    p = Person('tom')
    print('*' * 5)
test()  # 执行完函数，才会执行__del__ 在*号之后打印：del instance <__main__.Person object at 0x10236c588>

# p = Person('tom')
# print(p.name) # 执行完最后一句print，才会执行__del__，打印：del instance <__main__.Person object at 0x10236c588>

```



方法重载（overload）
函数名字相同，但是参数的类型不同, 其他语言可以使用，但是python的重载，如下面的例子所示, 同一个add函数可以实现，整数相加，字符串相加，也可以接受多个参数, 即灵活的形参，python语法本身就实现了其他语言的重载

```python
class Add:
    def add(self, a, b):
        return a + b
Add().add(1, 2)
Add().add('a', 'b')
```

override 重写，覆盖



猴子补丁（发现python的方法或类写的不好，用的不多）

```python
from test2 import Person
from test3 import get_score
def monkeypatch4Person():
    Person.get_score = get_score
monkeypatch4Person()
# 修改了Person，中的get_score方法
```

