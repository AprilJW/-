[TOP]

## 语言分类

### 面向机器

机器容易理解的语言，是一些机器指令，代表有汇编语言

### 面向过程

做一件事情，按步骤实现，第一步做什么，第二步做什么，如果情况A出现怎么处理，情况B处理怎么处理。适用问题规模小，可以按步骤实现，代表C语言

### 面向对象OOP

**5\***

是一种认识世界、分析世界的方法论。将万事万物抽象成为各种对象。

适用问题规模大，复杂的情况，代表C++、Java、Python

类class是一个**抽象**的概念

对象object，实例instance，都是一个实体，是个**具体**的概念

数据类，对应属性；动作类，操作类，行为，对应方法，类是对数据和操作的封装。

类中方法也是属性

表达式又名解析式，用来构建list，set,  dict, 比for循环效率高，使用列表表达式会立即生成新列表，占用大量的内存和cup；生成器的构建方式有生成器表达式，或者在函数中使用yield关键字，生成器是一个惰性对象，不会立即占用大量内存和cup，可以通过for循环和next方法获得里面的元素，生成器是一种迭代器。

### 面向对象3要素

**5\***

1.封装

第一，将属性和方法封装

第二，将数据和操作适当暴露给客户，对外提供一些接口, 该隐藏的隐藏，暴露的方法有property中的getter，setter方法. 可以用装饰器实现，也可以自己写函数加到property实例中；隐藏的方法有在属性和方法前面加一个下划线或者两个下划线

2.继承

分为单一继承和多继承，父类的属性和方法可以直接继承过来，

尽量多继承，不要在父类上改写，尽量自己写,OCP开闭原则

单一继承

```python
# 父类 超类 基类
# 子类 派生类
# 继承过程也叫派生过程
class Animal:
    def __init__(self, name):
        self._name = name

    def shout(self):
        print('{} , shouts'.format(self.__class__.__name__))
        # 在父类中，通过实例取得，子类的名字

class Cat(Animal): pass

c = Cat('tutu')
c.shout()
print(c.__class__.__base__)  #Animal
print(c.__class__.__bases__) #元组(Animal, )
print(c.__class__.__mro__) #元组，方法解析顺序，元组里面放的是类Cat Animal object
print(Cat.mro())  # 方法解析顺序，返回列表，同上
print(Animal.__subclasses__())  #Cat
print(int.__subclasses__())  #布尔型

# # object是根基类，没有父类，父类为None
# print(type(Cat)) type类型
# print(type(object)) type类型
```



3.多态

面向对象编程最灵活的地方，动态绑定，同一个方法在，不同的类型上

表现不同。例如继承自动物类的人类、猫类的操作'吃'方法不同

## python中的面向对象

定义：类名大驼峰（标识符），class关键字，定义后产生类对象，绑定到标识符上。

```python
class ClassName:
	语句块
```

```python
#实例化的真实过程，先调用了类的 obj = MyClass.__new__()
#然后调用了obj.__init__()方法，但是__init__()的返回值只能是None，
#内部做了优化所以，实例化之后返回一个对象，每次实例化都走一次__init__
#实例化与初始化
#先实例化再初始化
#__init__称为初始化，出厂配置，构造器，构造方法，dunder方法,第一参数必须是实例
```

```python
#类属性与类方法
#类属性与类方法本质上都是类属性
#类方法method，就是函数，可以通过类标识符.函数名，访问这个属性
#点号，就是成员访问符
```

普通方法，类方法，静态方法

例子：

```python
class Path:
    def __init__(self):
        self.name = 'tom'

    def method(self, m):  #普通方法，需要2个参数，类调用时不会注入第一参数，实例调用时，
        # 会将实例自身作为第一参数注入。
        print('普通方法：', self, m)

    @classmethod
    def class_method(cls, b):  #类方法，无论类调用还是实例调用，都会将类作为第一参数注入
        print('class method ：', cls, b)

    @staticmethod  #(用的少)静态方法, 无论类调用还是实例调用，都不会注入第一参数
    def static_method(b, a):
        print('static method ：', b, a)

# 普通方法例子
print(Path.method) #<function Path.method
print(Path().method) #bound method
Path().method(18) #实例调用时，第一参数为实例
Path.method('tom', 18) #类调用时，第一参数可以随便给一个值

#类方法例子
Path.class_method('tom')  #第一参数都为类，函数里面只要遇到self,就都是类
Path().class_method('tom')  #第一参数都为类

#静态方法
Path.static_method('11', '22')  #第一参数都不注入，需要传入两个参数
Path.static_method('11', '22')  #第一参数都不注入，需要传入两个参数

```

类对象与实例对象的\__class__  \_\_name\_\_ \_\_dict__

```python
class Person:
    height = 170

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def getage(self):
        print(self.name, __class__.__name__, self.__class__.__name__,type(self).__name__)
        # 后3种都可以取到类的__name__

pclass = Person
pinstance = Person('Tom', 18)

# __name__
pclass.__name__  # Person, 只有类可以取到名字，实例如果不定义取不到name

# __class__
pclass.__class__  # type
pinstance.__class__  # Person

# __dict___
pclass.__dict__  # {'height': 170 , '__init__':  ,'getage':,  '__doc__': }
pinstance.__dict__  # {'name': 'tom', 'age': 18}

print(*Person.__dict__.items(), sep='\n') #查看当前类的所有，__dict__

```

函数与类中出现+=比较

```python
class Person:
  height = 170
  def __init__(self, name, age):
    self.name = name
    self.age = age

p = Person('tom', 12)
p.height += 10 # 不会报错,不会走__init__，只会到类中去找height属性
p.height

def f():
    a = 10
    def f1():
        a += 1
        print(a)
    return f1
# f()()  报错

# 另一些例子
class Person:    
    def __init__(self, name, age=18):
        self.name = name
        self.age = age
        
    def growup(self, i=1):
        self.age += i
        print(self.age)
        
    def growup1(self, i=1):
        i += 1
        print('i', i)
        
    a = 1    
    def growup2(self):
        __class__.a += 1
        print('a', __class__.a)
    
    b = 2
    def growup3(self):
        b += 1
        
p = Person('tom')
p.growup()
p.growup1()
p.growup2()
p.growup3() #会报错
```

### 访问控制

私有，公有，protected

+ self.\_\_age = 1 私有属性，只能**类**中使用\_Person.\_\_age, 当前类名加私有属性名，**实例**不可以访问,  想查看到_Person.\_\_age，需要调用，

  实例  .\_\_dict\_\_

+ _self.\_age = 1 protected保护的属性，名字还是_age, 可以访问和修改

+ self.age = 1 公有属性

+ 同样适用于类的方法，分为私用，保护，公有方法，因为
  method也是一种属性

### 继承中的访问控制

```python
# 一下例子用来测试，正常代码不要这么写

class Animal:
    __COUNT = 100
    HEIGHT = 0

    def __init__(self, age, weight, height):
        self.__COUNT += 1
        self.age = age
        self.__weight = weight
        self.HEIGHT = height

    def eat(self):
        print('{}  eat'.format(self.__class__.__name__))

    def __getweight(self):
        print(self.__weight)

    @classmethod
    def showcount(cls):
        print(cls)
        print(cls.__dict__)
        print(cls.__COUNT)

    @classmethod
    def __showcount2(cls):
        print(cls.__COUNT)

    def showcount3(self):
        print(self.__COUNT)


class Cat(Animal):
    NAME = 'CAT'
    __COUNT = 200

# 测试（只是为了测试）
c = Cat(3, 5, 15)
c.eat()

# print(c.__COUNT)  #私有属性不可以通过实例直接访问访问
# CAT类的字典中_Cat__COUNT，访问方式_Cat__COUNT
# Animal类的字典中_Animal__COUNT ，访问方式_Animal__COUNT
# 实例的字典中没有这个属性，实例的字典中有_Animal__COUNT，访问方式_Animal__COUNT
print(Cat._Cat__COUNT)  # 200
print(Animal._Animal__COUNT)  # 100
print(c._Animal__COUNT)  # 101

# c.__getweight()  父类的私有方法不可以通过，实例访问
c._Animal__getweight()  #在实例字典中找到了_Animal__weight,值为5


```

### 实例属性的访问顺序

```python
class C:
    def __init__(self):
        print('C init ~~~~~')


class A(C):
    def __init__(self):
        #super().__init__()
        print('A init ~~~~')


class B(A):
    def __init__(self):
        #uper().__init__()
        print('B init ~~~~')
# 构造实例对象时，先找B中的__new__，再找
# A中的__new__, 都没找到，最后找的是object
# 中的__new__; 出厂配置时，初始化的顺序B，A，C
# 如果B中有则只初始化B，如果AC中都有只初始化A
# 如果只有C中有，则只初始化C, 如果想都初始化
# 则需要加2个super
b = B()

# 使用super()加载类中的方法，然后在子类中增强

# 继承的正常使用方法1
class Animal:
    def __init__(self, age):
        self.age = age

    def getage(self):
        print(self.age)

class Cat(Animal):
    def __init__(self, age, weight):
        super().__init__(age)
        self.weight = weight

c = Cat(1, 10)
c.getage()  # 1

# 继承的正常使用方法2(getage函数的位置改变了)
class Animal:
    def __init__(self, age):
        self.age = age

class Cat(Animal):
    def __init__(self, age, weight):
        super().__init__(age)
        self.weight = weight

    def getage(self):
        print(self.age)

c = Cat(1, 10)
c.getage()  # 1
```

### super用法

```python
#继承的测试例子（正常代码不要这么写）：

class Animal:
    def __init__(self, age):
        self.age = age

class Cat(Animal):
    def __init__(self, age, weight):
        super().__init__(age)
        self.weight = weight

    def getage(self):
        print(self.age)


c = Cat(5, 10)
c.getage()  # 5

class Animal:
    def __init__(self, age):
        self.__age = age


    def getage(self):
        print(self.__age)

class Cat(Animal):
    def __init__(self, age, weight):
        super().__init__(age)  # 等价于super(Cat, self).__init__(age)
        # 执行完super，在c实例的字典中多了一个_Animal__age : 3
        print(super())  # 打印当前类，和当前类对象，所以super接受的参数也是这两个
        self.__age = age + 1  # 执行完这一句，在c对象的字典中多了一个_Cat__age：4
        self.weight = weight

c = Cat(3, 10)
c.getage()  # Cat类中没有getage方法，所以到父类中找getage方法，找的是c实例中的_Animal__age方法，所以返回3


class Animal:
    def __init__(self, age):
        self.__age = age


class Cat(Animal):
    def __init__(self, age, weight):
        super().__init__(age)
        self.__age = age + 1
        self.weight = weight

    def getage(self):
        print(self.__age)

c = Cat(3, 10)
c.getage()  # 4

class A:
    def __init__(self, a, d=10):
        self.a = a
        self.__d = d

    def showd(self):
        return self.__d

class B(A):
    def __init__(self, b, c):
        self.b = b
        self.c = c
        A.__init__(self, b+c, b-c)
        #super(C, f).__init__(2)

    def printvalues(self):
        print(self.b)
        print(self.a)
        return self.showd()

b = B(2, 3)
print(b.printvalues()) # b=2, a=5 _A__d=-1

print(b.showd()) # -1

class Animal:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        return self._name  #不可以用return self.name, 会形成递归

    def shout(self):
        print('{} shouts'.format(self.__class__.__name__))


class Cat(Animal):
    def __init__(self, name):
        super().__init__(name)
    def shout(self):  #override
        # super()  #等价于super(self.__class__, self) super(Cat, self)
        super().shout()
        # 等价于super(Cat, self).shout()
        # Animal.shout(self) 不推荐
        # self.__class__.__base__.shout(self) #坚决不用，认识就可以
        print('miao miao')


c = Cat('tutu')
c.shout()  # 'Cat shout'
print(c.name)  # tutu
```



### 属性装饰器

```python
# 注意事项
class People:
    def __init__(self, name):
        self._name = name

    # @property     # 会形成递归，因为加上property后，name变成self的属性，name(self)等价于self.name
    # def name(self):
    #     return self.name

    # @property     # 初始化时会先执行self.name = name，在报递归错误之前，会报cannot set attribute 错误
    # def name(self):
    #     return self.name

    @property
    def name(self):
        return self._name
      
p = People('name: tutu')
print(p.name)
```



```python
# 属性装饰器2个例子
class Person:
    def __init__(self):
        self.__eyecolor = 'blue'

    @property
    def eyecolor(self):
        return self.__eyecolor

    @eyecolor.setter
    def eyecolor(self, value):
        self.__eyecolor = value

    @eyecolor.deleter # 用的不多
    def eyecolor(self):
        del self.__eyecolor

p = Person()
print(p.__dict__['_Person__eyecolor'])

#p.__eyecolor #访问不到
print(p.eyecolor) #eyecolor函数可以，当作属性来用
p.eyecolor = 'yellow' #修改属性，如果这个属性是只度模式，则不用写下面的settern和deleter方法
del p.eyecolor

# 与上面的方法类似
class Person:
    def __init__(self):
        self.__eyecolor = 'blue'

    def geteyecolor(self): return self.__eyecolor

    def seteyecolor(self, value): self.__eyecolor = value

    def deleyecolor(self): del self.__eyecolor

    eyecolor = property(geteyecolor, seteyecolor, deleyecolor, "I'm the 'eyecolor' property.")

p = Person()
print(p.geteyecolor()) #需要加括号
p.seteyecolor('yellow')
print(p.geteyecolor())
```

构造器与析构器

```python
class Person:
    def __init__(self, name): #构造器，构造函数，资源申请
        self.name = name

    def __del__(self): #析构器，构造函数,资源释放
        print('del instance', self)

def test():
    p = Person('tom')
    del p   #del x 并不直接调用 x.__del__() --- 前者会将 x 的引用计数减一，而后者仅会在 x 的引用计数变为零时被调用
    # 即在函数程序执行过程中引用计数变成0，调用了__del__
    print('*' * 10)
test()  # 执行完函数，不会打印：del instance <__main__.Person object at 0x10236c588>
# 因为在函数内部类对象的引用计数已经被清0了，会在*好上面打印，起作用的是def

def test():
    p = Person('tom')
    print('*' * 5)
test()  # 执行完函数，才会执行__del__ 在*号之后打印：del instance <__main__.Person object at 0x10236c588>

# p = Person('tom')
# print(p.name) # 执行完最后一句print，才会执行__del__，打印：del instance <__main__.Person object at 0x10236c588>

```



方法重载（overload）
函数名字相同，但是参数的类型不同, 其他语言可以使用，但是python的重载，如下面的例子所示, 同一个add函数可以实现，整数相加，字符串相加，也可以接受多个参数, 即灵活的形参，python语法本身就实现了其他语言的重载

```python
class Add:
    def add(self, a, b):
        return a + b
Add().add(1, 2)
Add().add('a', 'b')
```

override 重写，覆盖



猴子补丁（发现python的方法或类写的不好，用的不多）

```python
from test2 import Person
from test3 import get_score
def monkeypatch4Person():
    Person.get_score = get_score
monkeypatch4Person()
# 修改了Person，中的get_score方法
```

